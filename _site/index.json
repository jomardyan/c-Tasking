{
  "README.html": {
    "href": "README.html",
    "title": "c-Tasking | c-Tasking Documentation",
    "summary": "c-Tasking A lightweight C# library that simplifies threading and multitasking for modern .NET projects. Highlights Task wrappers and helpers for common concurrency patterns Simple thread lifecycle management and cancellation support Bounded managed thread pool with auto-queuing Scheduling utilities for periodic and one-time tasks Retry logic with exponential backoff Batch processing with controlled concurrency LINQ-style task extensions for fluent async code Documentation See the docs/ folder for full documentation: docs/HELP.md — Comprehensive guide and API reference docs/USAGE_AND_COMPARISON.md — Patterns and comparisons with .NET primitives docs/PROJECT_SETUP.md — Developer setup and CI/CD docs/NUGET_PUBLISHING.md — Publishing guide docs/CONTRIBUTING.md — Contribution guidelines docs/CHANGELOG.md — Release notes Installation dotnet add package c-Tasking Quick Examples Run a simple async task: using c_Tasking.Core; var result = await TaskWrapper.RunAsync(async () => { await Task.Delay(100); return 42; }); Use a bounded thread pool: using c_Tasking.Core; using var pool = new ManagedThreadPool(maxThreads: 4); pool.EnqueueTask(() => Console.WriteLine(\"Work\")); pool.WaitAll(); Schedule periodic work: using c_Tasking.Utilities; using var scheduler = new TaskScheduler(); scheduler.ScheduleRepeating(() => Console.WriteLine(\"Every 10 seconds\"), intervalMilliseconds: 10000); For more examples, see Examples/UsageExamples.cs. Key Features Target framework: .NET 10.0 Zero dependencies: Pure .NET implementation Minimal overhead: Thin wrappers around .NET APIs Production-ready: Full resource management and error handling Contributing See docs/CONTRIBUTING.md for contribution guidelines. License MIT License – see LICENSE for details."
  },
  "docs/CHANGELOG.html": {
    "href": "docs/CHANGELOG.html",
    "title": "Changelog | c-Tasking Documentation",
    "summary": "Changelog All notable changes to this project will be documented in this file. [1.0.0] - 2025-11-17 Initial release of c-Tasking Core components: TaskWrapper, SimpleThread, AsyncOperation, ManagedThreadPool Utilities: TaskScheduler, TaskRetry, ConcurrentBatcher, AdvancedUtilities Extensions: LINQ-style TaskExtensions This file reflects initial project state and is maintained manually."
  },
  "docs/CONTRIBUTING.html": {
    "href": "docs/CONTRIBUTING.html",
    "title": "Contributing to c-Tasking | c-Tasking Documentation",
    "summary": "Contributing to c-Tasking Thank you for your interest in contributing to c-Tasking! This document provides guidelines and instructions for contributing. Code of Conduct Please be respectful and professional in all interactions with other contributors and maintainers. Getting Started Fork the repository Clone your fork: git clone https://github.com/your-username/c-Tasking.git Create a branch: git checkout -b feature/your-feature Make your changes Test your changes: dotnet build && dotnet test Commit: git commit -am 'Add your feature' Push: git push origin feature/your-feature Open a Pull Request Development Setup Requirements .NET 10.0 SDK or later Visual Studio 2022 or VS Code with C# extension Building dotnet build Running Tests dotnet test Creating a Package dotnet pack -c Release Code Style Guidelines Follow C# naming conventions (PascalCase for public members, camelCase for local variables) Use meaningful variable and method names Add XML documentation comments to all public members Keep methods focused and reasonably sized Add unit tests for new features Example Code Style /// <summary> /// Performs an important operation. /// </summary> public async Task<int> PerformOperationAsync(string input) { ValidateInput(input); var result = await ProcessAsync(input); return result; } private static void ValidateInput(string input) { if (string.IsNullOrWhiteSpace(input)) throw new ArgumentException(\"Input cannot be empty\", nameof(input)); } Pull Request Process Update documentation and examples if needed Add unit tests for new functionality Ensure all tests pass: dotnet test Build the package: dotnet pack Update CHANGELOG.md Reference any related issues in the PR description Reporting Issues When reporting issues, please include: A clear, descriptive title Description of the issue Steps to reproduce Expected behavior Actual behavior Environment (OS, .NET version) Code sample if applicable Feature Requests Feature requests are welcome! Please provide: Clear description of the feature Use case and motivation Potential implementation approach Any related issues or discussions Documentation Help with documentation is always appreciated: Improving README clarity Adding more examples Clarifying API documentation Fixing typos Project Structure c-Tasking/ ├── Core/ # Core threading components │ ├── TaskWrapper.cs │ ├── SimpleThread.cs │ ├── AsyncOperation.cs │ └── ManagedThreadPool.cs ├── Utilities/ # Utility classes │ ├── TaskScheduler.cs │ ├── TaskRetry.cs │ └── ConcurrentBatcher.cs ├── Extensions/ # Extension methods │ └── TaskExtensions.cs ├── Examples/ # Usage examples │ └── UsageExamples.cs ├── README.md ├── CHANGELOG.md ├── LICENSE └── c-Tasking.csproj Release Process Releases are managed by maintainers. To request a release: Ensure all issues are resolved Update version in c-Tasking.csproj Update CHANGELOG.md Create a release PR After merge, create a GitHub release with tag Package and publish to NuGet Questions or Need Help? Open an issue for questions Check existing documentation Review example code Ask in discussions Thank you for contributing to c-Tasking!"
  },
  "docs/HELP.html": {
    "href": "docs/HELP.html",
    "title": "c-Tasking Library - Complete Documentation | c-Tasking Documentation",
    "summary": "c-Tasking Library - Complete Documentation Version: 1.0.0 Last Updated: November 18, 2025 Status: Release Ready License: MIT ?? Table of Contents Introduction & Quick Start Installation Core Components Utilities & Advanced Features Complete API Reference Usage Examples Best Practices Common Patterns Development & Contribution Publishing & Distribution FAQ & Troubleshooting Introduction & Quick Start What is c-Tasking? c-Tasking is a lightweight, zero-dependency C# library that simplifies threading and multitasking. It wraps .NET's native APIs in easy-to-use classes and methods, making complex threading operations straightforward and safe. Key Features ? Simple Task Execution - Run sync/async code with minimal boilerplate ? Thread Management - Easy thread lifecycle and cancellation control ? Thread Pooling - Automatic queuing and load balancing ? Task Scheduling - One-time and repeating scheduled tasks ? Retry Logic - Automatic retry with exponential backoff ? Batch Processing - Concurrent batch operations ? LINQ Extensions - Fluent async operation chaining ? Production Ready - Full resource management and timeout handling ? Well Documented - Comprehensive guides and examples Zero Dependencies - Pure .NET 10.0 implementation Quick Start (5 Minutes) using c_Tasking.Core; using c_Tasking.Utilities; using c_Tasking.Extensions; // 1. Simple async task await TaskWrapper.RunAsync(async () => { await Task.Delay(1000); Console.WriteLine(\"Task complete!\"); }); // 2. Simple thread var thread = new SimpleThread(); thread.Start(cancellationToken => { while (!cancellationToken.IsCancellationRequested) { Console.WriteLine(\"Working...\"); Thread.Sleep(100); } }); Thread.Sleep(500); thread.Stop(timeoutMilliseconds: 5000); // 3. Thread pool using var pool = new ManagedThreadPool(maxThreads: 4); for (int i = 0; i < 10; i++) pool.EnqueueTask(() => DoWork()); pool.WaitAll(); pool.StopAll(); // 4. Task scheduling using var scheduler = new TaskScheduler(); scheduler.ScheduleRepeating(() => Console.WriteLine(\"Runs every 10 seconds\"), intervalMilliseconds: 10000); // 5. Retry logic var result = await TaskRetry.ExecuteWithRetry( async () => await CallApiAsync(), maxAttempts: 3, initialDelayMilliseconds: 100 ); // 6. Batch processing var batcher = new ConcurrentBatcher<int>(batchSize: 10, maxConcurrentBatches: 3); await batcher.ProcessBatches( Enumerable.Range(1, 100), async item => { await ProcessItemAsync(item); } ); Installation Via NuGet dotnet add package c-Tasking Or in your .csproj: <ItemGroup> <PackageReference Include=\"c-Tasking\" Version=\"1.0.0\" /> </ItemGroup> From Source git clone https://github.com/jomardyan/c-Tasking.git cd c-Tasking dotnet build -c Release Using Local NuGet dotnet pack -c Release -o ./nupkg dotnet add package c-Tasking --source ./nupkg Required Dependencies .NET 10.0+ (no other external dependencies) C# 12.0+ compatible compiler Core Components 1. TaskWrapper - Simple Task Execution The most basic way to run tasks on the thread pool without threading complexity. Overview using c_Tasking.Core; // Sync action, run async await TaskWrapper.Run(() => DoSyncWork()); // Sync function with return var result = await TaskWrapper.Run(() => GetValue()); // Async action await TaskWrapper.RunAsync(async () => await DoAsyncWork()); // Async function with return var data = await TaskWrapper.RunAsync(async () => await GetDataAsync()); // Multiple tasks in parallel await TaskWrapper.RunParallel( Task.Run(() => Work1()), Task.Run(() => Work2()), Task.Run(() => Work3()) ); // Wait with timeout TaskWrapper.WaitWithTimeout(myTask, 5000); // throws if exceeds 5 seconds Methods Method Returns Description Run(Action) Task Execute sync code asynchronously Run<T>(Func<T>) Task Execute sync code with return value RunAsync(Func<Task>) Task Execute async code RunAsync<T>(Func<Task<T>>) Task Execute async code with return value RunParallel(params Task[]) Task Execute multiple tasks in parallel RunParallel<T>(params Task<T>[]) Task<T[]> Execute tasks parallel, return results WaitWithTimeout(Task, int) void Wait with timeout, throws TimeoutException WaitWithTimeout<T>(Task<T>, int) T Wait with timeout, return result WaitAny(params Task[]) Task Wait for any task to complete WaitAny<T>(params Task<T>[]) Task<Task > Wait for any generic task to complete When to Use Quick async operations Parallel work without complex coordination Simple threading needs Task pool execution 2. SimpleThread - Thread Management Direct thread control with simplified lifecycle and cancellation. Overview using c_Tasking.Core; // Basic thread var thread = new SimpleThread(); thread.Start(() => { for (int i = 0; i < 10; i++) { Console.WriteLine($\"Step {i}\"); Thread.Sleep(100); } }); thread.Join(); // Wait for completion Console.WriteLine($\"Thread ID: {thread.GetThreadId()}\"); Console.WriteLine($\"Is running: {thread.IsRunning}\"); Console.WriteLine($\"Is alive: {thread.IsAlive}\"); // Thread with cancellation support var cancelThread = new SimpleThread(); cancelThread.Start(cancellationToken => { while (!cancellationToken.IsCancellationRequested) { Console.WriteLine(\"Working...\"); Thread.Sleep(200); } }); Thread.Sleep(1000); cancelThread.Stop(timeoutMilliseconds: 5000); // Graceful shutdown // Set thread properties thread.SetPriority(ThreadPriority.Highest); thread.SetAsBackgroundThread(false); Properties Property Type Description IsRunning bool Whether thread is currently executing IsAlive bool Whether underlying thread is alive Methods Method Returns Description Start(Action) void Start thread with simple action Start(Action<CancellationToken>) void Start with cancellation support Join(int) bool Wait for thread completion Stop(int) void Stop gracefully with timeout SetPriority(ThreadPriority) void Set thread priority SetAsBackgroundThread(bool) void Set background thread flag GetThreadId() int? Get managed thread ID When to Use Long-running operations Operations needing cancellation Background work with lifecycle control When you need direct thread manipulation 3. AsyncOperation - Async Tracking Manual control over async operations for tracking completion, failures, and results. Overview using c_Tasking.Core; // Create from async function var operation = AsyncOperation.Create(async () => { await Task.Delay(500); Console.WriteLine(\"Done\"); }); await operation.WaitAsync(); // With result var resultOp = AsyncOperation<int>.Create(async () => { await Task.Delay(500); return 42; }); int result = await resultOp.WaitAsync(); // Manual operation control var manualOp = new AsyncOperation<string>(); _ = Task.Run(async () => { await Task.Delay(1000); manualOp.SetResult(\"Completed!\"); }); var finalResult = await manualOp.WaitAsync(); // Handle errors var errorOp = new AsyncOperation(); errorOp.SetException(new Exception(\"Something failed\")); // Cancel operation var cancelOp = new AsyncOperation(); cancelOp.Cancel(); // Wait with timeout try { await resultOp.WaitAsync(timeoutMilliseconds: 2000); } catch (OperationCanceledException) { Console.WriteLine(\"Operation timed out\"); } Methods Method Returns Description Create(Func<Task>) AsyncOperation Create and run async operation Create<T>(Func<Task<T>>) AsyncOperation Create with result WaitAsync() Task Wait for completion WaitAsync(int) Task Wait with timeout SetResult() / SetResult<T>(T) void Mark operation complete SetException(Exception) void Mark operation failed Cancel() void Cancel operation IsCompleted { get; } bool Check if complete Result { get; } T? Get result (generic only) When to Use Complex async workflows Manual result tracking Callback-based integrations Integration with legacy code 4. ManagedThreadPool - Thread Pool Management Manage multiple concurrent threads with automatic queuing and load balancing. Overview using c_Tasking.Core; // Create pool with max 4 concurrent threads using var pool = new ManagedThreadPool(maxThreads: 4); // Enqueue tasks for (int i = 0; i < 20; i++) { int taskNum = i; pool.EnqueueTask(() => { Console.WriteLine($\"Task {taskNum} executing\"); Thread.Sleep(1000); }); } // Enqueue async work await pool.EnqueueAsync(async () => { await Task.Delay(500); Console.WriteLine(\"Async task done\"); }); // Monitor pool var stats = pool.GetStats(); Console.WriteLine($\"Active threads: {stats.ActiveThreads}\"); Console.WriteLine($\"Queued tasks: {stats.QueuedTasks}\"); Console.WriteLine($\"Max threads: {stats.MaxThreads}\"); // Properties int active = pool.ActiveThreadCount; int queued = pool.QueuedTaskCount; // Wait for all to complete pool.WaitAll(timeoutMilliseconds: 30000); // Graceful shutdown pool.StopAll(timeoutMilliseconds: 5000); // Automatic cleanup with using statement ThreadPoolStats Property Type Description MaxThreads int Maximum thread count ActiveThreads int Currently active threads QueuedTasks int Tasks waiting in queue TotalThreads int Total threads created Methods Method Returns Description EnqueueTask(Action) void Queue synchronous task EnqueueAsync(Func<Task>) void Queue async task WaitAll(int) void Wait for all tasks to complete StopAll(int) void Stop all threads gracefully GetStats() ThreadPoolStats Get pool statistics ActiveThreadCount { get; } int Current active threads QueuedTaskCount { get; } int Current queued tasks Dispose() void Cleanup resources When to Use Process many items concurrently Manage thread count Load balancing Limited resource pools Utilities & Advanced Features 1. TaskScheduler - Scheduled Execution Schedule tasks to run at specific times or intervals. Overview using c_Tasking.Utilities; using var scheduler = new TaskScheduler(); // Run once after delay int taskId1 = scheduler.ScheduleOnce(() => { Console.WriteLine(\"Runs once after 2 seconds\"); }, delayMilliseconds: 2000); // Run repeatedly int taskId2 = scheduler.ScheduleRepeating(() => { Console.WriteLine(\"Runs every second\"); }, intervalMilliseconds: 1000); // Run with initial delay then repeat int taskId3 = scheduler.ScheduleWithDelay(() => { Console.WriteLine(\"First after 1s, then every 2s\"); }, delayMilliseconds: 1000, intervalMilliseconds: 2000); // Async scheduling int taskId4 = scheduler.ScheduleOnceAsync(async () => { await Task.Delay(500); Console.WriteLine(\"Async scheduled task\"); }, delayMilliseconds: 1000); // Async repeating int taskId5 = scheduler.ScheduleRepeatingAsync(async () => { await Task.Delay(100); Console.WriteLine(\"Async every 5 seconds\"); }, intervalMilliseconds: 5000); // Cancel a task scheduler.Cancel(taskId1); // Cancel all tasks scheduler.CancelAll(); // Auto-cleanup with using statement Methods Method Returns Description ScheduleOnce(Action, int) int Run once after delay ScheduleRepeating(Action, int) int Run repeatedly ScheduleWithDelay(Action, int, int) int Run with delay then repeat ScheduleOnceAsync(Func<Task>, int) int Async run once ScheduleRepeatingAsync(Func<Task>, int) int Async repeat Cancel(int) bool Cancel specific task CancelAll() void Cancel all tasks Dispose() void Cleanup resources When to Use Periodic tasks Cleanup operations Heartbeats and monitoring Timeouts and delays 2. TaskRetry - Automatic Retry Retry operations with exponential backoff and custom error handling. Overview using c_Tasking.Utilities; // Simple retry with exponential backoff var result = await TaskRetry.ExecuteWithRetry( async () => await FetchDataFromApi(), maxAttempts: 5, initialDelayMilliseconds: 100 ); // With custom error filter await TaskRetry.ExecuteWithRetry( async () => await RiskyOperation(), maxAttempts: 3, initialDelayMilliseconds: 500, shouldRetry: ex => ex is TimeoutException // Only retry timeouts ); // Synchronous retry var data = TaskRetry.Execute( () => ParseComplexData(), maxAttempts: 3, initialDelayMilliseconds: 200 ); // Retry without result await TaskRetry.ExecuteWithRetry( async () => await SendMessage(), maxAttempts: 4 ); Backoff Strategy Attempt 1: fails immediately Attempt 2: waits 100ms (initialDelay) Attempt 3: waits 200ms (initialDelay � 2) Attempt 4: waits 400ms (initialDelay � 4) Attempt 5: waits 800ms (initialDelay � 8) (continues doubling until maxAttempts reached) Methods Method Returns Description ExecuteWithRetry<T>(Func<Task<T>>, ...) Task Retry async with return ExecuteWithRetry(Func<Task>, ...) Task Retry async without result Execute<T>(Func<T>, ...) T Retry sync with return Execute(Func<Task>, ...) Task Retry sync without result When to Use Network calls API requests Transient failures Unreliable operations 3. ConcurrentBatcher - Batch Processing Process items in batches concurrently for efficient resource usage. Overview using c_Tasking.Utilities; var items = Enumerable.Range(1, 100).ToList(); // Basic batching var batcher = new ConcurrentBatcher<int>( batchSize: 10, // Process 10 items per batch maxConcurrentBatches: 3 // Run 3 batches in parallel ); // Process with results await batcher.ProcessBatches( items, async item => { var result = await ProcessItemAsync(item); return result; }, async results => { Console.WriteLine($\"Batch complete: {results.Count} items\"); await SaveResults(results); } ); // Process without results await batcher.ProcessBatches( items, async item => { await DoSomething(item); }, async () => { Console.WriteLine(\"Batch processing complete\"); } ); Methods Method Returns Description ProcessBatches<TResult>(...) Task Process with results callback ProcessBatches(...) Task Process without results When to Use Bulk operations API batch processing Data transformation Large dataset processing 4. TaskExtensions - LINQ-like Operations Fluent operations on tasks for cleaner async code. Overview using c_Tasking.Extensions; // Success callback await Task.Run(() => 42) .OnSuccess(result => Console.WriteLine($\"Success: {result}\")); // Exception handler await someTask .OnException(ex => Console.WriteLine($\"Error: {ex.Message}\")); // Cancellation handler await someTask .OnCancelled(() => Console.WriteLine(\"Task was cancelled\")); // Finally block await someTask .Finally(() => Console.WriteLine(\"Task ended\")); // Transform result (Map) var doubled = await Task.Run(() => 5) .Map(x => x * 2); // Async transformation var data = await Task.Run(() => \"api\") .MapAsync(async endpoint => await GetDataFrom(endpoint)); // Chain operations var result = await Task.Run(() => 10) .Chain(async num => { await Task.Delay(100); return num * 2; }); // Try wait (returns success status) var (completed, result) = someTask.TryWait(timeoutMs: 5000); // Ignore exceptions await riskyTask.IgnoreException(); var value = await riskyTaskWithResult.IgnoreException<int>(); // Parallel execution await TaskExtensions.WaitAllInParallel(task1, task2, task3); // Wait for first completion await TaskExtensions.WaitAnyToComplete(task1, task2, task3); Methods Method Returns Description OnSuccess(task, callback) Task Run callback on success OnSuccess<T>(task, callback) Task Run callback with result OnException(task, callback) Task Run callback on error OnCancelled(task, callback) Task Run callback on cancel Finally(task, callback) Task Run callback always Map<T,R>(task, mapper) Task Transform result MapAsync<T,R>(task, mapper) Task Async transform Chain(task, nextTask) Task Chain operations Chain<T,R>(task, nextTask) Task Chain with result TryWait(task, ms) (bool, T?) Wait with timeout IgnoreException(task) Task Suppress errors IgnoreException<T>(task) Task<T?> Suppress errors, return null on failure WaitAllInParallel(tasks) Task All tasks in parallel WaitAnyToComplete(tasks) Task Any task to complete When to Use Cleaner async code Operation chaining Error handling Result transformation Complete API Reference Namespaces using c_Tasking.Core; // TaskWrapper, SimpleThread, AsyncOperation, ManagedThreadPool using c_Tasking.Utilities; // TaskScheduler, TaskRetry, ConcurrentBatcher using c_Tasking.Extensions; // TaskExtensions Core Classes Summary Class Purpose Lifecycle TaskWrapper Task execution Static methods SimpleThread Thread management Create instance AsyncOperation Async tracking Create instance ManagedThreadPool Thread pool IDisposable TaskScheduler Task scheduling IDisposable TaskRetry Retry logic Static methods ConcurrentBatcher<T> Batch processing Create instance TaskExtensions Extension methods Extension methods Usage Examples Example 1: Download Multiple Files with Retry var urls = new[] { \"http://...\", \"http://...\", \"http://...\" }; var batcher = new ConcurrentBatcher<string>(batchSize: 5, maxConcurrentBatches: 3); await batcher.ProcessBatches( urls, async url => { return await TaskRetry.ExecuteWithRetry( async () => await DownloadFile(url), maxAttempts: 3, shouldRetry: ex => ex is HttpRequestException ); }, async results => { await SaveResults(results); Console.WriteLine($\"Downloaded {results.Count} files\"); } ); Example 2: Long-Running Background Task var thread = new SimpleThread(); thread.Start(cancellationToken => { while (!cancellationToken.IsCancellationRequested) { try { PerformBackgroundWork(); Thread.Sleep(5000); } catch (Exception ex) { LogError(ex); } } }); // Application running... // Gracefully stop on shutdown thread.Stop(timeoutMilliseconds: 10000); Example 3: Scheduled Data Sync using var scheduler = new TaskScheduler(); // Sync every 30 minutes scheduler.ScheduleRepeatingAsync(async () => { await SyncDataWithServer(); }, intervalMilliseconds: 30 * 60 * 1000); // Cleanup every 24 hours scheduler.ScheduleWithDelay( async () => await CleanupOldData(), delayMilliseconds: 24 * 60 * 60 * 1000, intervalMilliseconds: 24 * 60 * 60 * 1000 ); Example 4: Process Queue with Thread Pool using var pool = new ManagedThreadPool(maxThreads: Environment.ProcessorCount); var queueItems = GetQueueItems(); foreach (var item in queueItems) { pool.EnqueueTask(() => { try { ProcessQueueItem(item); } catch (Exception ex) { LogError(ex); } }); } pool.WaitAll(timeoutMilliseconds: 60000); pool.StopAll(timeoutMilliseconds: 5000); Example 5: Retry with Custom Logic var result = await TaskRetry.ExecuteWithRetry( async () => { var response = await apiClient.GetAsync(\"https://api.example.com/data\"); return await response.Content.ReadAsStringAsync(); }, maxAttempts: 5, initialDelayMilliseconds: 500, shouldRetry: ex => { // Retry on timeout or server errors (5xx) return ex is TimeoutException || (ex is HttpRequestException hre && hre.Message.Contains(\"5\")); } ); Example 6: LINQ-style Async Chain var result = await FetchUserAsync(userId) .Map(user => user.Email) .MapAsync(async email => await SendWelcomeEmail(email)) .OnSuccess(() => Console.WriteLine(\"Email sent\")) .OnException(ex => Console.WriteLine($\"Error: {ex.Message}\")) .Finally(() => Console.WriteLine(\"Process complete\")) .IgnoreException(); Best Practices 1. Resource Cleanup Always use using statement for ManagedThreadPool and TaskScheduler: using var pool = new ManagedThreadPool(4); // Your code // Automatic cleanup on scope exit 2. Error Handling Wrap operations in try-catch for production: try { var result = await TaskRetry.ExecuteWithRetry( async () => await Operation(), maxAttempts: 3, shouldRetry: ex => ex is not InvalidOperationException ); } catch (AggregateException ae) { foreach (var inner in ae.InnerExceptions) LogError(inner); } 3. Timeout Management Set appropriate timeouts based on operation type: // Network operations: 30 seconds // File operations: 60 seconds // Local operations: 5 seconds TaskWrapper.WaitWithTimeout(task, 30000); 4. Thread Count Selection Use Environment.ProcessorCount as baseline: var pool = new ManagedThreadPool( maxThreads: Environment.ProcessorCount * 2 ); 5. Logging in Production Log task progress: scheduler.ScheduleOnceAsync(async () => { logger.LogInformation(\"Scheduled task started\"); await DoWork(); logger.LogInformation(\"Scheduled task completed\"); }, delayMilliseconds: 1000); 6. Cancellation Support Always check cancellation tokens: thread.Start(cancellationToken => { while (!cancellationToken.IsCancellationRequested) { // Do work if (cancellationToken.IsCancellationRequested) break; } }); 7. Resource Limits Monitor pool statistics: var stats = pool.GetStats(); if (stats.QueuedTasks > 1000) logger.LogWarning(\"High queue depth: {Count}\", stats.QueuedTasks); Common Patterns Fire and Forget (Safe) _ = Task.Run(() => DoWork()).IgnoreException(); Parallel Execution await TaskExtensions.WaitAllInParallel( Task.Run(() => Work1()), Task.Run(() => Work2()), Task.Run(() => Work3()) ); Sequential Chain await task1 .Chain(async _ => await task2) .Chain(async _ => await task3); Conditional Retry await TaskRetry.ExecuteWithRetry( operation, maxAttempts: 3, shouldRetry: ex => ex is TimeoutException || ex is HttpRequestException ); Batch and Schedule using var scheduler = new TaskScheduler(); scheduler.ScheduleRepeatingAsync(async () => { await batcher.ProcessBatches(items, processor); }, intervalMilliseconds: 60000); Poll Until Condition var timeoutAt = DateTime.UtcNow.AddSeconds(30); while (DateTime.UtcNow < timeoutAt) { if (CheckCondition()) break; await Task.Delay(100); } Background Work Shutdown var thread = new SimpleThread(); thread.Start(ct => BackgroundWork(ct)); // On shutdown using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)); thread.Stop(10000); if (!thread.Join(2000)) logger.LogWarning(\"Thread did not stop gracefully\"); Development & Contribution Getting Started Clone the repository: git clone https://github.com/jomardyan/c-Tasking.git cd c-Tasking Setup development environment: dotnet restore dotnet build dotnet test Create a feature branch: git checkout -b feature/your-feature Code Style Guidelines Follow C# naming conventions (PascalCase for public members) Use meaningful variable names Add XML documentation comments to all public members Keep methods focused and reasonably sized Add unit tests for new features Example Documentation /// <summary> /// Performs an important operation asynchronously. /// </summary> /// <param name=\"input\">The input string to process.</param> /// <returns>The number of items processed.</returns> /// <exception cref=\"ArgumentException\">Thrown when input is empty.</exception> public async Task<int> PerformOperationAsync(string input) { ValidateInput(input); var result = await ProcessAsync(input); return result; } private static void ValidateInput(string input) { if (string.IsNullOrWhiteSpace(input)) throw new ArgumentException(\"Input cannot be empty\", nameof(input)); } Project Structure c-Tasking/ ??? Core/ ? ??? TaskWrapper.cs ? ??? SimpleThread.cs ? ??? AsyncOperation.cs ? ??? ManagedThreadPool.cs ??? Utilities/ ? ??? TaskScheduler.cs ? ??? TaskRetry.cs ? ??? ConcurrentBatcher.cs ? ??? AdvancedUtilities.cs ??? Extensions/ ? ??? TaskExtensions.cs ??? Examples/ ? ??? UsageExamples.cs ??? ... (documentation and config files) Pull Request Process Update documentation and examples if needed Add unit tests for new functionality Ensure all tests pass: dotnet test Build the package: dotnet pack Update CHANGELOG.md Reference any related issues in PR description Reporting Issues When reporting issues, include: Clear, descriptive title Description of the issue Steps to reproduce Expected behavior Actual behavior Environment (OS, .NET version) Code sample if applicable Feature Requests Feature requests welcome! Please provide: Clear description of the feature Use case and motivation Potential implementation approach Any related issues Publishing & Distribution Version Management Follow Semantic Versioning (MAJOR.MINOR.PATCH): 1.0.0 ? Initial release 1.1.0 ? New features, backward compatible 1.0.1 ? Bug fixes, backward compatible 2.0.0 ? Breaking changes Updating Version Update version in c-Tasking.csproj: <Version>1.1.0</Version> Update CHANGELOG.md with changes Commit and create tag: git add c-Tasking.csproj CHANGELOG.md git commit -m \"Version 1.1.0\" git tag v1.1.0 git push origin v1.1.0 Publishing to NuGet Automatic (GitHub Actions): Create a release with tag format v1.0.0 GitHub Actions automatically publishes to NuGet Manual Publishing: # Create package dotnet pack -c Release # Push to NuGet dotnet nuget push \"./bin/Release/c-Tasking.1.0.0.nupkg\" \\ --api-key YOUR_API_KEY \\ --source https://api.nuget.org/v3/index.json Getting NuGet API Key Sign in to https://www.nuget.org/ Go to profile settings Click \"Edit Profile\" Go to \"API Keys\" Create new key with \"Push\" permissions Copy the key Package Verification # Wait a few minutes for indexing dotnet package search c-Tasking # Or visit: https://www.nuget.org/packages/c-Tasking/ Pre-release Versions <Version>1.0.0-beta.1</Version> <Version>1.0.0-rc.1</Version> FAQ & Troubleshooting Q: Which should I use: TaskWrapper or SimpleThread? A: Use TaskWrapper for: Quick async operations Parallel work Simple threading needs Use SimpleThread for: Long-running operations Operations needing cancellation Direct thread control Q: How do I stop a thread gracefully? A: Use the Stop method with a timeout: thread.Stop(timeoutMilliseconds: 5000); // 5 second timeout The thread should check cancellationToken.IsCancellationRequested regularly to respond quickly. Q: What happens if a retry limit is exceeded? A: The last exception is thrown: try { await TaskRetry.ExecuteWithRetry(operation, maxAttempts: 3); } catch (Exception ex) { // This is the exception from the 3rd attempt } Q: How do I set thread priority? A: Use SetPriority: thread.SetPriority(ThreadPriority.Highest); // Options: Lowest, BelowNormal, Normal, AboveNormal, Highest Q: Can I use this with async/await? A: Yes! All components support async operations: await TaskWrapper.RunAsync(async () => { /* async work */ }); scheduler.ScheduleRepeatingAsync(async () => { /* async work */ }, 1000); await pool.EnqueueAsync(async () => { /* async work */ }); Q: What if my task needs to access shared state? A: Use proper synchronization: private readonly object _lock = new(); private int _counter = 0; pool.EnqueueTask(() => { lock (_lock) { _counter++; } }); Q: How do I timeout a long operation? A: Use WaitWithTimeout or TryWait: // Throws TimeoutException TaskWrapper.WaitWithTimeout(myTask, timeoutMilliseconds: 5000); // Returns bool var (completed, _) = myTask.TryWait(timeoutMilliseconds: 5000); Q: Can I track task progress? A: Monitor pool statistics: var stats = pool.GetStats(); Console.WriteLine($\"Progress: {stats.ActiveThreads}/{stats.MaxThreads}\"); Q: What's the performance overhead? A: Minimal. c-Tasking is a thin wrapper around .NET threading APIs with negligible overhead. Q: Is this thread-safe? A: Yes, all public APIs are thread-safe. However, your own shared state needs synchronization. Q: Can I use this in a web application? A: Yes, but consider: Thread pools may grow unbounded with many requests Use ManagedThreadPool with reasonable maxThreads Prefer TaskWrapper for request handling Use TaskScheduler for background tasks Q: How do I handle cancellation properly? A: Regularly check the cancellation token: thread.Start(cancellationToken => { while (!cancellationToken.IsCancellationRequested) { // Do work // Check frequently if (cancellationToken.IsCancellationRequested) return; Thread.Sleep(100); } }); Q: What happens if an operation is canceled? A: An OperationCanceledException is thrown: try { await operation.WaitAsync(timeoutMilliseconds: 100); } catch (OperationCanceledException) { Console.WriteLine(\"Operation timed out or was cancelled\"); } Additional Resources GitHub Repository: https://github.com/jomardyan/c-Tasking NuGet Package: https://www.nuget.org/packages/c-Tasking/ Issues & Discussions: https://github.com/jomardyan/c-Tasking/issues .NET Documentation: https://docs.microsoft.com/en-us/dotnet/ Threading Guide: https://docs.microsoft.com/en-us/dotnet/standard/threading/ Summary c-Tasking provides a comprehensive set of threading and multitasking utilities for C# developers. With zero dependencies and a clean API, it simplifies complex threading operations while maintaining production-ready reliability and performance. Key Takeaways: ? Use TaskWrapper for simple async operations ? Use SimpleThread for long-running operations ? Use ManagedThreadPool for concurrent task management ? Use TaskScheduler for scheduled work ? Use TaskRetry for fault-tolerant operations ? Use ConcurrentBatcher for bulk processing ? Use TaskExtensions for fluent async code For more information, see individual component documentation or visit the GitHub repository. Version: 1.0.0 Last Updated: November 17, 2025 License: MIT Status: Production Ready Questions? Create an issue on GitHub or check the examples in UsageExamples.cs."
  },
  "docs/NUGET_PUBLISHING.html": {
    "href": "docs/NUGET_PUBLISHING.html",
    "title": "NuGet Publishing Guide | c-Tasking Documentation",
    "summary": "NuGet Publishing Guide Prerequisites .NET 10.0 SDK or later NuGet account at https://www.nuget.org/ NuGet API key from your account settings Publishing Steps 1. Local Testing Build and test the package locally: # Build the project dotnet build -c Release # Create the NuGet package dotnet pack -c Release -o ./nupkg # Test the package locally (optional) # You can test by creating a temporary project and adding the package from the local path 2. Get Your API Key Sign in to https://www.nuget.org/ Go to your profile settings Click \"Edit Profile\" Go to \"API Keys\" Create a new key with \"Push\" permissions Copy the key 3. Configure API Key Store your NuGet API key (choose one method): Method 1: Global Configuration dotnet nuget add source https://api.nuget.org/v3/index.json --name nuget.org dotnet nuget update source nuget.org --username __USERNAME__ --password YOUR_API_KEY --store-password-in-clear-text Method 2: GitHub Secrets (Recommended for CI/CD) Go to your repository settings Click \"Secrets and variables\" → \"Actions\" Create a new secret named NUGET_API_KEY Paste your API key value 4. Publish to NuGet Option A: Manual Publishing # Create package dotnet pack -c Release # Push to NuGet dotnet nuget push \"./bin/Release/c-Tasking.1.0.0.nupkg\" --api-key YOUR_API_KEY --source https://api.nuget.org/v3/index.json Option B: Using GitHub Actions (Recommended) The project includes GitHub Actions workflows in .github/workflows/ Create a release with tag format v1.0.0 The publish.yml workflow will automatically: Build the project Create the NuGet package Push to NuGet Create a GitHub release # Create and push a tag git tag v1.0.0 git push origin v1.0.0 # GitHub Actions will automatically publish to NuGet 5. Verify Publication After publishing, verify the package: # Wait a few minutes for indexing, then search dotnet package search c-Tasking # Or visit: https://www.nuget.org/packages/c-Tasking/ Version Management Updating Version Update the version in c-Tasking.csproj: <Version>1.1.0</Version> Update CHANGELOG.md with changes Commit and create a tag: git add c-Tasking.csproj CHANGELOG.md git commit -m \"Version 1.1.0\" git tag v1.1.0 git push origin v1.1.0 Semantic Versioning Follow Semantic Versioning: MAJOR (X.0.0): Breaking changes MINOR (1.X.0): New features, backward compatible PATCH (1.0.X): Bug fixes, backward compatible Pre-release Versions For pre-release versions, use: <Version>1.0.0-beta.1</Version> <Version>1.0.0-rc.1</Version> Package Contents Verification The NuGet package includes: All compiled assemblies XML documentation files README.md LICENSE Icon (icon.png) Source link support Verify in c-Tasking.csproj: <ItemGroup> <None Include=\"README.md\" Pack=\"true\" PackagePath=\"\\\"/> <None Include=\"LICENSE\" Pack=\"true\" PackagePath=\"\\\"/> <None Include=\"icon.png\" Pack=\"true\" PackagePath=\"\\\"/> </ItemGroup> Troubleshooting Package Already Exists If you get \"Package with this version already exists\": This is normal - NuGet doesn't allow republishing the same version Update the version number and try again API Key Invalid # Verify your API key is correct dotnet nuget list source # Update the key dotnet nuget update source nuget.org --username __USERNAME__ --password YOUR_NEW_KEY Symbol Packages To publish symbols for debugging: <PropertyGroup> <GenerateDocumentationFile>true</GenerateDocumentationFile> <PublishRepositoryUrl>true</PublishRepositoryUrl> <EmbedUntrackedSources>true</EmbedUntrackedSources> <DebugType>embedded</DebugType> </PropertyGroup> Package Icons Add an icon to your package: Create a 128x128 PNG file named icon.png Place it in the project root It will be included in the NuGet package References NuGet Documentation NuGet CLI Reference Semantic Versioning Keep a Changelog Support For issues with NuGet publishing, refer to: NuGet official documentation GitHub Actions logs in your repository NuGet support community"
  },
  "docs/PROJECT_SETUP.html": {
    "href": "docs/PROJECT_SETUP.html",
    "title": "Project Setup and Distribution Guide | c-Tasking Documentation",
    "summary": "Project Setup and Distribution Guide \uD83D\uDCC1 Project Structure c-Tasking/ ├── Core/ # Core threading and task management │ ├── TaskWrapper.cs # Simple task execution wrapper │ ├── SimpleThread.cs # Thread management with cancellation │ ├── AsyncOperation.cs # Async operation tracking │ └── ManagedThreadPool.cs # Thread pool with auto-queuing │ ├── Utilities/ # Utility and helper classes │ ├── TaskScheduler.cs # Task scheduling utilities │ ├── TaskRetry.cs # Retry logic with backoff │ ├── ConcurrentBatcher.cs # Batch processing utilities │ └── AdvancedUtilities.cs # Advanced parallel/throttling utilities │ ├── Extensions/ # LINQ-style extension methods │ └── TaskExtensions.cs # Task extension methods │ ├── Examples/ # Usage examples │ └── UsageExamples.cs # Comprehensive examples │ ├── .github/workflows/ # CI/CD workflows │ ├── build.yml # Build and test workflow │ └── publish.yml # NuGet publishing workflow │ ├── README.md # Main documentation ├── HELP.md # Comprehensive library overview ├── USAGE_AND_COMPARISON.md # Usage comparisons and patterns ├── CONTRIBUTING.md # Contributing guidelines ├── CHANGELOG.md # Version history ├── NUGET_PUBLISHING.md # NuGet publishing guide ├── LICENSE # MIT License ├── icon.png # Package icon ├── c-Tasking.csproj # Project file with NuGet metadata ├── c-Tasking.sln # Visual Studio solution └── .gitignore # Git ignore rules \uD83D\uDEE0️ Development Setup Requirements .NET 10.0 SDK or later Visual Studio 2022 / VS Code with C# extension Git Initial Setup # Clone the repository git clone https://github.com/jomardyan/c-Tasking.git cd c-Tasking # Restore dependencies dotnet restore # Build the project dotnet build # Run any tests dotnet test # Create local NuGet package dotnet pack -c Release -o ./nupkg VS Code: Integrated Terminal Font If you use VS Code, configure the integrated terminal to use a Nerd Font for proper glyphs and icons. You can change this via the settings UI (Ctrl+, -> Features -> Terminal -> Integrated: Font Family) or by adding the following to your user/workspace settings.json: { \"terminal.integrated.fontFamily\": \"MesloLGM Nerd Font\" } This repository includes a workspace setting at .vscode/settings.json that sets the Terminal font family to MesloLGM Nerd Font as an example — update as needed to match your installed Nerd Font. \uD83D\uDCE6 Package Information NuGet Package Details Property Value Package ID c-Tasking Current Version 1.0.0 Framework .NET 10.0+ License MIT Author Jomar Dyan Repository github.com/jomardyan/c-Tasking Tags threading, async, tasks, multitasking, concurrency Package Contents The NuGet package includes: c-Tasking.1.0.0.nupkg ├── lib/ │ └── net10.0/ │ ├── c-Tasking.dll │ └── c-Tasking.xml (documentation) ├── README.md ├── LICENSE ├── icon.png └── package metadata (nuspec) \uD83D\uDE80 Distribution Channels 1. NuGet.org (Primary) Official Package: https://www.nuget.org/packages/c-Tasking/ Installation: dotnet add package c-Tasking Publishing Process: Create a GitHub release with tag (e.g., v1.0.0) GitHub Actions automatically publishes to NuGet Verify at https://www.nuget.org/packages/c-Tasking/ 2. GitHub Releases Releases are available at: https://github.com/jomardyan/c-Tasking/releases Features: Source code archives (zip/tar.gz) Change logs Release notes Binary downloads 3. Source Code Repository: https://github.com/jomardyan/c-Tasking Clone directly: git clone https://github.com/jomardyan/c-Tasking.git \uD83D\uDCDD Documentation Files Core Documentation File Purpose README.md Main introduction, features, quick start, API reference HELP.md Comprehensive guide and examples USAGE_AND_COMPARISON.md Usage patterns and comparisons CHANGELOG.md Version history and changes CONTRIBUTING.md Contribution guidelines LICENSE MIT License terms Development Documentation File Purpose NUGET_PUBLISHING.md NuGet publishing guide .github/workflows/ CI/CD workflows \uD83D\uDD04 CI/CD Pipeline Automated Workflows 1. Build Workflow (.github/workflows/build.yml) Triggers on: push to main/develop, pull requests Steps: Setup .NET 10.0 Restore dependencies Build in Release mode Run tests Create NuGet package Upload artifacts 2. Publishing Workflow (.github/workflows/publish.yml) Triggers on: version tag push (e.g., v1.0.0) Steps: Build release version Create NuGet package Push to NuGet.org Create GitHub release Manual Publishing # Locally dotnet pack -c Release dotnet nuget push bin/Release/c-Tasking.1.0.0.nupkg --api-key YOUR_API_KEY # Using GitHub CLI gh release create v1.0.0 --generate-notes \uD83D\uDD10 Security & Best Practices API Key Management Never commit API keys to repository Use GitHub Secrets for CI/CD Rotate keys periodically Use read-only keys when possible Code Quality XML documentation on all public APIs Zero compiler warnings in Release mode Nullable reference types enabled Consistent code style Testing Comprehensive examples in UsageExamples.cs All public APIs documented Example patterns for common scenarios \uD83D\uDCCA Versioning Strategy Follow Semantic Versioning (MAJOR.MINOR.PATCH): 1.0.0 → Initial release 1.1.0 → New features, backward compatible 1.0.1 → Bug fixes, backward compatible 2.0.0 → Breaking changes Update version in: c-Tasking.csproj - <Version> tag CHANGELOG.md - Add release section CONTRIBUTING.md - Update if needed \uD83D\uDCCB Release Checklist Before releasing a new version: [ ] Update version in .csproj [ ] Update CHANGELOG.md [ ] Verify all tests pass [ ] Test NuGet package locally [ ] Verify documentation is current [ ] Commit changes: git commit -am \"Release v1.x.x\" [ ] Create tag: git tag v1.x.x [ ] Push: git push origin v1.x.x [ ] GitHub Actions publishes to NuGet [ ] Create GitHub release with notes \uD83C\uDFAF Quick Command Reference Building & Testing dotnet build # Debug build dotnet build -c Release # Release build dotnet test # Run tests dotnet clean # Clean build artifacts Packaging dotnet pack -c Release # Create NuGet package dotnet pack -c Release -o ./nupkg # Create and output to folder Publishing # Manual NuGet push dotnet nuget push ./nupkg/c-Tasking.1.0.0.nupkg \\ --api-key YOUR_API_KEY \\ --source https://api.nuget.org/v3/index.json # GitHub release gh release create v1.0.0 --generate-notes Documentation Generation # The project generates XML documentation automatically # Located at: bin/Release/net10.0/c-Tasking.xml \uD83D\uDD17 Important Links NuGet Package: https://www.nuget.org/packages/c-Tasking/ GitHub Repository: https://github.com/jomardyan/c-Tasking GitHub Issues: https://github.com/jomardyan/c-Tasking/issues Discussions: https://github.com/jomardyan/c-Tasking/discussions \uD83D\uDCDE Support For questions or issues: Check documentation files Review UsageExamples.cs Open GitHub issue Visit GitHub discussions \uD83C\uDF93 Additional Resources Microsoft .NET Documentation NuGet Documentation Semantic Versioning Keep a Changelog GitHub Actions Documentation Last Updated: November 17, 2025 Version: 1.0.0"
  },
  "docs/USAGE_AND_COMPARISON.html": {
    "href": "docs/USAGE_AND_COMPARISON.html",
    "title": "c-Tasking — Usage Cases & Comparison with .NET Built-in APIs | c-Tasking Documentation",
    "summary": "c-Tasking — Usage Cases & Comparison with .NET Built-in APIs This document compares common usage scenarios using the native .NET primitives versus the c-Tasking library wrappers. It highlights how c-Tasking simplifies certain patterns and when to prefer the library or built-in APIs. The examples target .NET 10 (net10.0) and c-Tasking v1.x. Goals Show simple examples for common patterns: background work, scheduled tasks, retries, batching, and thread management. Explain when to use the standard .NET approach versus the c-Tasking helper classes. Provide trade-offs on clarity, performance, and control. Component Mapping TaskWrapper ⇄ Task / Task.Run / Task.WhenAll / Task.WhenAny SimpleThread ⇄ Thread (System.Threading) / long-running background threads AsyncOperation ⇄ TaskCompletionSource / manual Task-based coordination ManagedThreadPool ⇄ ThreadPool / TPL (Task Parallel Library) TaskScheduler ⇄ System.Threading.Timer / Task.Delay / scheduled jobs (Quartz.NET, Hangfire) TaskRetry ⇄ Manual try/catch with Task.Delay or libraries like Polly ConcurrentBatcher ⇄ Parallel.ForEach / custom batching using SemaphoreSlim / Dataflow library TaskExtensions ⇄ Common Task chaining and continuation patterns c-Tasking specifics and notes Exception handling: c-Tasking helpers generally use the ErrorHandler singleton to log exceptions rather than throwing by default. Check the specific APIs when you need to propagate errors. IDisposable & lifecycle: TaskScheduler and ManagedThreadPool are IDisposable and should be used with using var or manually disposed for graceful cleanup. Default thread behavior: SimpleThread defaults to IsBackground = false; set as background if you want the process to exit without waiting for it. Sync/Async overloads: Many utilities have both synchronous and async overloads (e.g., TaskRetry.Execute and ExecuteWithRetry), choose the one matching your code path. Usage Examples & Comparison 1) Simple Asynchronous Task / Fire-and-Forget .NET (built-in): // Fire-and-forget (use sparingly; exceptions must be handled manually) _ = Task.Run(async () => { try { await DoWorkAsync(); } catch (Exception ex) { Log(ex); } }); c-Tasking: // Slightly more concise with TaskWrapper _ = TaskWrapper.RunAsync(async () => await DoWorkAsync()); // Or for synchronous action _ = TaskWrapper.Run(() => DoWork()); Why use c-Tasking? Cleaner, more intention-revealing syntax for simple one-off tasks. For advanced needs or fine-grained control, prefer Task.Run or direct Tasks. 2) Long-Running/Background Thread .NET (built-in): var t = new Thread(() => { while (!cancellationToken.IsCancellationRequested) { DoWork(); } }); t.IsBackground = true; t.Start(); c-Tasking: var thread = new SimpleThread(); // CancellationToken support thread.Start(ct => { while (!ct.IsCancellationRequested) { DoWork(); } }); // Or start without token // thread.Start(() => { while(true) { DoWork(); } }); // Stop gracefully thread.Stop(5000); Why use c-Tasking? SimpleThread combines cancellation and lifecycle management, avoiding repeated setup boilerplate. Use raw Thread for specialized OS thread-configurations or extreme performance tuning. 3) Managed Thread Pool / Worker Pool .NET (built-in): ThreadPool (QueueUserWorkItem) for lightweight tasks. TPL for tasks via Task.Run, Parallel.ForEach, Dataflow for pipelines. c-Tasking: using var pool = new ManagedThreadPool(maxThreads: 4); // Enqueue a synchronous task pool.EnqueueTask(() => ProcessItem(item)); // Enqueue an async task (helper overload) pool.EnqueueAsync(async () => await ProcessItemAsync(item)); pool.WaitAll(5000); Why use c-Tasking? Simpler interface for queuing tasks where you prefer a bounded worker pool. When using higher-level TPL constructs or Dataflow, those may be more appropriate for high scalability or built-in scheduling. 4) Scheduled Work .NET (built-in): System.Threading.Timer or Task.Delay loops; for production, Quartz.NET or Hangfire. c-Tasking: using var scheduler = new TaskScheduler(); int id = scheduler.ScheduleRepeating(() => DoPeriodicWork(), intervalMilliseconds: 10000); // Schedule an async operation int asyncTaskId = scheduler.ScheduleRepeatingAsync(async () => await DoPeriodicWorkAsync(), 10000); // Cancel scheduled tasks or use Dispose scheduler.Cancel(id); Why use c-Tasking? Simplifies repeating + once-off scheduling with built-in cancellation support. For enterprise schedulers with persistence or distributed job handling, use third-party libraries. 5) Retry Logic / Exponential Backoff .NET (built-in): // Manual approach for (int i = 0; i < maxAttempts; i++) { try { return await Operation(); } catch (Exception ex) { if (i == maxAttempts - 1) throw; await Task.Delay(100 * (1 << i)); } } Polly (recommended in many apps): var policy = Policy.Handle<Exception>().WaitAndRetryAsync(3, i => TimeSpan.FromMilliseconds(100 * Math.Pow(2, i))); await policy.ExecuteAsync(() => Operation()); c-Tasking: // Async retry with optional filter predicate var result = await TaskRetry.ExecuteWithRetry(async () => await Operation(), maxAttempts: 3, initialDelayMilliseconds: 100); // Sync retry var syncResult = TaskRetry.Execute(() => OperationSync(), maxAttempts: 3); Why use c-Tasking? TaskRetry is a lightweight, library-specific retry helper. For more complex policies (circuit-breaker, fallback), prefer Polly. 6) Batch Processing .NET (built-in): Parallel.ForEach or custom batching using SemaphoreSlim to limit concurrency. Dataflow Block pattern for pipeline parallelism. c-Tasking: var batcher = new ConcurrentBatcher<int>(batchSize: 50, maxConcurrentBatches: 3); await batcher.ProcessBatches(items, async item => await Process(item), async results => await SaveBatch(results)); Why use c-Tasking? ConcurrentBatcher is built-in and simple to configure for many typical batching needs. For more advanced backpressure and memory efficiency, TPL Dataflow or custom streaming design provides more control. Performance & Behavior Considerations c-Tasking intentionally reduces ceremony and boilerplate for common patterns. That usually improves readability and reduces bugs. Where performance matters (high-throughput scenarios), prefer native TPL constructs (Task.Run, Parallel, ThreadPool, Dataflow) which are tuned in .NET. c-Tasking's thread-pool is useful for bounded concurrency and simpler lifecycle; for high concurrency, prefer ThreadPool or Task based concurrency. Always measure for critical paths: Stopwatch, logging counters and load testing to confirm whether the abstraction suits your workload. Reliability, Cancellation & Disposal c-Tasking includes Dispose and Stop patterns to help with graceful shutdown, and uses CancellationToken across APIs where it makes sense. For disposable objects (TaskScheduler, ManagedThreadPool) prefer using var to ensure cleanup. Native APIs provide more low-level control — you must manage CancellationTokenSource and joining threads yourself, and ensure Dispose() patterns are enforced for resources. When to use .NET primitives Need the highest performance or scalability. Want minimal runtime footprint and direct control. Using advanced parallelism patterns requiring TPL Dataflow or Parallel constructs. Integrating with enterprise scheduler or persistent job systems. When to use c-Tasking You want simpler, intention-focused APIs for common concurrency scenarios. Your codebase can benefit from small, lightweight wrappers making common patterns clearer. You prefer a built-in solution that includes retries, scheduling, and throttling helpers without additional dependencies. Migration tips Replace early ad-hoc Thread usage with SimpleThread when you need cancellation and lifecycle features. For modules with Task.Run usage, TaskWrapper gives simple helper methods — keep Task.Run if you need more advanced control. If you already use Polly or other libraries for retry and resilience, it is fine to keep them; TaskRetry is handy for small projects. Tip: Use examples See Examples/UsageExamples.cs for runnable samples that mirror the examples in this document. Summary c-Tasking is a small, focused set of helpers aimed at making developer intent clearer and code cleaner for common concurrency needs. Use it where productivity and simplicity matter. For heavy workloads or enterprise-level control, prefer the underlying .NET primitives or ecosystem tools. Additional Resources docs/HELP.md — comprehensive guide and examples docs/PROJECT_SETUP.md — project setup and packaging guide Examples/UsageExamples.cs — runnable examples from the repo This document was generated from code and design patterns in the c-Tasking repository."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | c-Tasking Documentation",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | c-Tasking Documentation",
    "summary": "Introduction"
  }
}